// AUTO-GENERATED

#ifndef _GI_GSK_PARSELOCATION_IMPL_HPP_
#define _GI_GSK_PARSELOCATION_IMPL_HPP_

namespace gi {

namespace repository {

namespace Gsk {

namespace base {

static gsize _field_bytes_get (const ::GskParseLocation* obj) { return (gsize) obj->bytes; }
// gsize ParseLocation::bytes (const ::GskParseLocation* obj /*none*/);
// gsize ParseLocation::bytes (const ::GskParseLocation* obj /*none*/);
gsize base::ParseLocationBase::bytes_ () const noexcept
{
  typedef gsize (*call_wrap_t) (const ::GskParseLocation* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_bytes_get;
  auto _temp_ret = call_wrap_v ((const ::GskParseLocation*) (gobj_()));
  return _temp_ret;
}

static void _field_bytes_set (::GskParseLocation* obj, gsize _value) { obj->bytes = (decltype(obj->bytes)) _value; }
//  ParseLocation::bytes (::GskParseLocation* obj /*none*/, gsize _value);
// void ParseLocation::bytes (::GskParseLocation* obj /*none*/, gsize _value);
void base::ParseLocationBase::bytes_ (gsize _value) noexcept
{
  typedef void (*call_wrap_t) (::GskParseLocation* obj, gsize _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_bytes_set;
  auto _value_to_c = _value;
  call_wrap_v ((::GskParseLocation*) (gobj_()), (gsize) (_value_to_c));
}

static gsize _field_chars_get (const ::GskParseLocation* obj) { return (gsize) obj->chars; }
// gsize ParseLocation::chars (const ::GskParseLocation* obj /*none*/);
// gsize ParseLocation::chars (const ::GskParseLocation* obj /*none*/);
gsize base::ParseLocationBase::chars_ () const noexcept
{
  typedef gsize (*call_wrap_t) (const ::GskParseLocation* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_chars_get;
  auto _temp_ret = call_wrap_v ((const ::GskParseLocation*) (gobj_()));
  return _temp_ret;
}

static void _field_chars_set (::GskParseLocation* obj, gsize _value) { obj->chars = (decltype(obj->chars)) _value; }
//  ParseLocation::chars (::GskParseLocation* obj /*none*/, gsize _value);
// void ParseLocation::chars (::GskParseLocation* obj /*none*/, gsize _value);
void base::ParseLocationBase::chars_ (gsize _value) noexcept
{
  typedef void (*call_wrap_t) (::GskParseLocation* obj, gsize _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_chars_set;
  auto _value_to_c = _value;
  call_wrap_v ((::GskParseLocation*) (gobj_()), (gsize) (_value_to_c));
}

static gsize _field_lines_get (const ::GskParseLocation* obj) { return (gsize) obj->lines; }
// gsize ParseLocation::lines (const ::GskParseLocation* obj /*none*/);
// gsize ParseLocation::lines (const ::GskParseLocation* obj /*none*/);
gsize base::ParseLocationBase::lines_ () const noexcept
{
  typedef gsize (*call_wrap_t) (const ::GskParseLocation* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_lines_get;
  auto _temp_ret = call_wrap_v ((const ::GskParseLocation*) (gobj_()));
  return _temp_ret;
}

static void _field_lines_set (::GskParseLocation* obj, gsize _value) { obj->lines = (decltype(obj->lines)) _value; }
//  ParseLocation::lines (::GskParseLocation* obj /*none*/, gsize _value);
// void ParseLocation::lines (::GskParseLocation* obj /*none*/, gsize _value);
void base::ParseLocationBase::lines_ (gsize _value) noexcept
{
  typedef void (*call_wrap_t) (::GskParseLocation* obj, gsize _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_lines_set;
  auto _value_to_c = _value;
  call_wrap_v ((::GskParseLocation*) (gobj_()), (gsize) (_value_to_c));
}

static gsize _field_line_bytes_get (const ::GskParseLocation* obj) { return (gsize) obj->line_bytes; }
// gsize ParseLocation::line_bytes (const ::GskParseLocation* obj /*none*/);
// gsize ParseLocation::line_bytes (const ::GskParseLocation* obj /*none*/);
gsize base::ParseLocationBase::line_bytes_ () const noexcept
{
  typedef gsize (*call_wrap_t) (const ::GskParseLocation* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_line_bytes_get;
  auto _temp_ret = call_wrap_v ((const ::GskParseLocation*) (gobj_()));
  return _temp_ret;
}

static void _field_line_bytes_set (::GskParseLocation* obj, gsize _value) { obj->line_bytes = (decltype(obj->line_bytes)) _value; }
//  ParseLocation::line_bytes (::GskParseLocation* obj /*none*/, gsize _value);
// void ParseLocation::line_bytes (::GskParseLocation* obj /*none*/, gsize _value);
void base::ParseLocationBase::line_bytes_ (gsize _value) noexcept
{
  typedef void (*call_wrap_t) (::GskParseLocation* obj, gsize _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_line_bytes_set;
  auto _value_to_c = _value;
  call_wrap_v ((::GskParseLocation*) (gobj_()), (gsize) (_value_to_c));
}

static gsize _field_line_chars_get (const ::GskParseLocation* obj) { return (gsize) obj->line_chars; }
// gsize ParseLocation::line_chars (const ::GskParseLocation* obj /*none*/);
// gsize ParseLocation::line_chars (const ::GskParseLocation* obj /*none*/);
gsize base::ParseLocationBase::line_chars_ () const noexcept
{
  typedef gsize (*call_wrap_t) (const ::GskParseLocation* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_line_chars_get;
  auto _temp_ret = call_wrap_v ((const ::GskParseLocation*) (gobj_()));
  return _temp_ret;
}

static void _field_line_chars_set (::GskParseLocation* obj, gsize _value) { obj->line_chars = (decltype(obj->line_chars)) _value; }
//  ParseLocation::line_chars (::GskParseLocation* obj /*none*/, gsize _value);
// void ParseLocation::line_chars (::GskParseLocation* obj /*none*/, gsize _value);
void base::ParseLocationBase::line_chars_ (gsize _value) noexcept
{
  typedef void (*call_wrap_t) (::GskParseLocation* obj, gsize _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_line_chars_set;
  auto _value_to_c = _value;
  call_wrap_v ((::GskParseLocation*) (gobj_()), (gsize) (_value_to_c));
}


} // namespace base

} // namespace Gsk

} // namespace repository

} // namespace gi


#if defined(__has_include)
#if __has_include(<gsk/parselocation_extra_def_impl.hpp>)
#include <gsk/parselocation_extra_def_impl.hpp>
#endif
#endif


#if defined(__has_include)
#if __has_include(<gsk/parselocation_extra_impl.hpp>)
#include <gsk/parselocation_extra_impl.hpp>
#endif
#endif

#endif
