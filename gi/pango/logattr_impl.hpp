// AUTO-GENERATED

#ifndef _GI_PANGO_LOGATTR_IMPL_HPP_
#define _GI_PANGO_LOGATTR_IMPL_HPP_

namespace gi {

namespace repository {

namespace Pango {

namespace base {

static guint _field_is_line_break_get (const ::PangoLogAttr* obj) { return (guint) obj->is_line_break; }
// guint LogAttr::is_line_break (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_line_break (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_line_break_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_line_break_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_line_break_set (::PangoLogAttr* obj, guint _value) { obj->is_line_break = (decltype(obj->is_line_break)) _value; }
//  LogAttr::is_line_break (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_line_break (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_line_break_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_line_break_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_mandatory_break_get (const ::PangoLogAttr* obj) { return (guint) obj->is_mandatory_break; }
// guint LogAttr::is_mandatory_break (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_mandatory_break (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_mandatory_break_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_mandatory_break_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_mandatory_break_set (::PangoLogAttr* obj, guint _value) { obj->is_mandatory_break = (decltype(obj->is_mandatory_break)) _value; }
//  LogAttr::is_mandatory_break (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_mandatory_break (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_mandatory_break_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_mandatory_break_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_char_break_get (const ::PangoLogAttr* obj) { return (guint) obj->is_char_break; }
// guint LogAttr::is_char_break (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_char_break (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_char_break_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_char_break_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_char_break_set (::PangoLogAttr* obj, guint _value) { obj->is_char_break = (decltype(obj->is_char_break)) _value; }
//  LogAttr::is_char_break (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_char_break (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_char_break_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_char_break_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_white_get (const ::PangoLogAttr* obj) { return (guint) obj->is_white; }
// guint LogAttr::is_white (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_white (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_white_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_white_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_white_set (::PangoLogAttr* obj, guint _value) { obj->is_white = (decltype(obj->is_white)) _value; }
//  LogAttr::is_white (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_white (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_white_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_white_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_cursor_position_get (const ::PangoLogAttr* obj) { return (guint) obj->is_cursor_position; }
// guint LogAttr::is_cursor_position (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_cursor_position (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_cursor_position_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_cursor_position_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_cursor_position_set (::PangoLogAttr* obj, guint _value) { obj->is_cursor_position = (decltype(obj->is_cursor_position)) _value; }
//  LogAttr::is_cursor_position (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_cursor_position (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_cursor_position_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_cursor_position_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_word_start_get (const ::PangoLogAttr* obj) { return (guint) obj->is_word_start; }
// guint LogAttr::is_word_start (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_word_start (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_word_start_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_word_start_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_word_start_set (::PangoLogAttr* obj, guint _value) { obj->is_word_start = (decltype(obj->is_word_start)) _value; }
//  LogAttr::is_word_start (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_word_start (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_word_start_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_word_start_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_word_end_get (const ::PangoLogAttr* obj) { return (guint) obj->is_word_end; }
// guint LogAttr::is_word_end (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_word_end (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_word_end_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_word_end_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_word_end_set (::PangoLogAttr* obj, guint _value) { obj->is_word_end = (decltype(obj->is_word_end)) _value; }
//  LogAttr::is_word_end (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_word_end (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_word_end_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_word_end_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_sentence_boundary_get (const ::PangoLogAttr* obj) { return (guint) obj->is_sentence_boundary; }
// guint LogAttr::is_sentence_boundary (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_sentence_boundary (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_sentence_boundary_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_sentence_boundary_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_sentence_boundary_set (::PangoLogAttr* obj, guint _value) { obj->is_sentence_boundary = (decltype(obj->is_sentence_boundary)) _value; }
//  LogAttr::is_sentence_boundary (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_sentence_boundary (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_sentence_boundary_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_sentence_boundary_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_sentence_start_get (const ::PangoLogAttr* obj) { return (guint) obj->is_sentence_start; }
// guint LogAttr::is_sentence_start (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_sentence_start (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_sentence_start_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_sentence_start_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_sentence_start_set (::PangoLogAttr* obj, guint _value) { obj->is_sentence_start = (decltype(obj->is_sentence_start)) _value; }
//  LogAttr::is_sentence_start (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_sentence_start (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_sentence_start_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_sentence_start_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_sentence_end_get (const ::PangoLogAttr* obj) { return (guint) obj->is_sentence_end; }
// guint LogAttr::is_sentence_end (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_sentence_end (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_sentence_end_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_sentence_end_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_sentence_end_set (::PangoLogAttr* obj, guint _value) { obj->is_sentence_end = (decltype(obj->is_sentence_end)) _value; }
//  LogAttr::is_sentence_end (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_sentence_end (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_sentence_end_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_sentence_end_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_backspace_deletes_character_get (const ::PangoLogAttr* obj) { return (guint) obj->backspace_deletes_character; }
// guint LogAttr::backspace_deletes_character (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::backspace_deletes_character (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::backspace_deletes_character_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_backspace_deletes_character_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_backspace_deletes_character_set (::PangoLogAttr* obj, guint _value) { obj->backspace_deletes_character = (decltype(obj->backspace_deletes_character)) _value; }
//  LogAttr::backspace_deletes_character (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::backspace_deletes_character (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::backspace_deletes_character_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_backspace_deletes_character_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_expandable_space_get (const ::PangoLogAttr* obj) { return (guint) obj->is_expandable_space; }
// guint LogAttr::is_expandable_space (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_expandable_space (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_expandable_space_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_expandable_space_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_expandable_space_set (::PangoLogAttr* obj, guint _value) { obj->is_expandable_space = (decltype(obj->is_expandable_space)) _value; }
//  LogAttr::is_expandable_space (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_expandable_space (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_expandable_space_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_expandable_space_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_is_word_boundary_get (const ::PangoLogAttr* obj) { return (guint) obj->is_word_boundary; }
// guint LogAttr::is_word_boundary (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::is_word_boundary (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::is_word_boundary_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_word_boundary_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_is_word_boundary_set (::PangoLogAttr* obj, guint _value) { obj->is_word_boundary = (decltype(obj->is_word_boundary)) _value; }
//  LogAttr::is_word_boundary (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::is_word_boundary (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::is_word_boundary_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_is_word_boundary_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_break_inserts_hyphen_get (const ::PangoLogAttr* obj) { return (guint) obj->break_inserts_hyphen; }
// guint LogAttr::break_inserts_hyphen (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::break_inserts_hyphen (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::break_inserts_hyphen_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_break_inserts_hyphen_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_break_inserts_hyphen_set (::PangoLogAttr* obj, guint _value) { obj->break_inserts_hyphen = (decltype(obj->break_inserts_hyphen)) _value; }
//  LogAttr::break_inserts_hyphen (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::break_inserts_hyphen (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::break_inserts_hyphen_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_break_inserts_hyphen_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_break_removes_preceding_get (const ::PangoLogAttr* obj) { return (guint) obj->break_removes_preceding; }
// guint LogAttr::break_removes_preceding (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::break_removes_preceding (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::break_removes_preceding_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_break_removes_preceding_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_break_removes_preceding_set (::PangoLogAttr* obj, guint _value) { obj->break_removes_preceding = (decltype(obj->break_removes_preceding)) _value; }
//  LogAttr::break_removes_preceding (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::break_removes_preceding (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::break_removes_preceding_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_break_removes_preceding_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}

static guint _field_reserved_get (const ::PangoLogAttr* obj) { return (guint) obj->reserved; }
// guint LogAttr::reserved (const ::PangoLogAttr* obj /*none*/);
// guint LogAttr::reserved (const ::PangoLogAttr* obj /*none*/);
guint base::LogAttrBase::reserved_ () const noexcept
{
  typedef guint (*call_wrap_t) (const ::PangoLogAttr* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_reserved_get;
  auto _temp_ret = call_wrap_v ((const ::PangoLogAttr*) (gobj_()));
  return _temp_ret;
}

static void _field_reserved_set (::PangoLogAttr* obj, guint _value) { obj->reserved = (decltype(obj->reserved)) _value; }
//  LogAttr::reserved (::PangoLogAttr* obj /*none*/, guint _value);
// void LogAttr::reserved (::PangoLogAttr* obj /*none*/, guint _value);
void base::LogAttrBase::reserved_ (guint _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoLogAttr* obj, guint _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_reserved_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoLogAttr*) (gobj_()), (guint) (_value_to_c));
}


} // namespace base

} // namespace Pango

} // namespace repository

} // namespace gi


#if defined(__has_include)
#if __has_include(<pango/logattr_extra_def_impl.hpp>)
#include <pango/logattr_extra_def_impl.hpp>
#endif
#endif


#if defined(__has_include)
#if __has_include(<pango/logattr_extra_impl.hpp>)
#include <pango/logattr_extra_impl.hpp>
#endif
#endif

#endif
