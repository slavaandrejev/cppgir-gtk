// AUTO-GENERATED

#ifndef _GI_PANGO_MATRIX_IMPL_HPP_
#define _GI_PANGO_MATRIX_IMPL_HPP_

namespace gi {

namespace repository {

namespace Pango {

namespace base {

static gdouble _field_xx_get (const ::PangoMatrix* obj) { return (gdouble) obj->xx; }
// gdouble Matrix::xx (const ::PangoMatrix* obj /*none*/);
// gdouble Matrix::xx (const ::PangoMatrix* obj /*none*/);
gdouble base::MatrixBase::xx_ () const noexcept
{
  typedef gdouble (*call_wrap_t) (const ::PangoMatrix* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_xx_get;
  auto _temp_ret = call_wrap_v ((const ::PangoMatrix*) (gobj_()));
  return _temp_ret;
}

static void _field_xx_set (::PangoMatrix* obj, gdouble _value) { obj->xx = (decltype(obj->xx)) _value; }
//  Matrix::xx (::PangoMatrix* obj /*none*/, gdouble _value);
// void Matrix::xx (::PangoMatrix* obj /*none*/, gdouble _value);
void base::MatrixBase::xx_ (gdouble _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoMatrix* obj, gdouble _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_xx_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoMatrix*) (gobj_()), (gdouble) (_value_to_c));
}

static gdouble _field_xy_get (const ::PangoMatrix* obj) { return (gdouble) obj->xy; }
// gdouble Matrix::xy (const ::PangoMatrix* obj /*none*/);
// gdouble Matrix::xy (const ::PangoMatrix* obj /*none*/);
gdouble base::MatrixBase::xy_ () const noexcept
{
  typedef gdouble (*call_wrap_t) (const ::PangoMatrix* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_xy_get;
  auto _temp_ret = call_wrap_v ((const ::PangoMatrix*) (gobj_()));
  return _temp_ret;
}

static void _field_xy_set (::PangoMatrix* obj, gdouble _value) { obj->xy = (decltype(obj->xy)) _value; }
//  Matrix::xy (::PangoMatrix* obj /*none*/, gdouble _value);
// void Matrix::xy (::PangoMatrix* obj /*none*/, gdouble _value);
void base::MatrixBase::xy_ (gdouble _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoMatrix* obj, gdouble _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_xy_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoMatrix*) (gobj_()), (gdouble) (_value_to_c));
}

static gdouble _field_yx_get (const ::PangoMatrix* obj) { return (gdouble) obj->yx; }
// gdouble Matrix::yx (const ::PangoMatrix* obj /*none*/);
// gdouble Matrix::yx (const ::PangoMatrix* obj /*none*/);
gdouble base::MatrixBase::yx_ () const noexcept
{
  typedef gdouble (*call_wrap_t) (const ::PangoMatrix* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_yx_get;
  auto _temp_ret = call_wrap_v ((const ::PangoMatrix*) (gobj_()));
  return _temp_ret;
}

static void _field_yx_set (::PangoMatrix* obj, gdouble _value) { obj->yx = (decltype(obj->yx)) _value; }
//  Matrix::yx (::PangoMatrix* obj /*none*/, gdouble _value);
// void Matrix::yx (::PangoMatrix* obj /*none*/, gdouble _value);
void base::MatrixBase::yx_ (gdouble _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoMatrix* obj, gdouble _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_yx_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoMatrix*) (gobj_()), (gdouble) (_value_to_c));
}

static gdouble _field_yy_get (const ::PangoMatrix* obj) { return (gdouble) obj->yy; }
// gdouble Matrix::yy (const ::PangoMatrix* obj /*none*/);
// gdouble Matrix::yy (const ::PangoMatrix* obj /*none*/);
gdouble base::MatrixBase::yy_ () const noexcept
{
  typedef gdouble (*call_wrap_t) (const ::PangoMatrix* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_yy_get;
  auto _temp_ret = call_wrap_v ((const ::PangoMatrix*) (gobj_()));
  return _temp_ret;
}

static void _field_yy_set (::PangoMatrix* obj, gdouble _value) { obj->yy = (decltype(obj->yy)) _value; }
//  Matrix::yy (::PangoMatrix* obj /*none*/, gdouble _value);
// void Matrix::yy (::PangoMatrix* obj /*none*/, gdouble _value);
void base::MatrixBase::yy_ (gdouble _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoMatrix* obj, gdouble _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_yy_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoMatrix*) (gobj_()), (gdouble) (_value_to_c));
}

static gdouble _field_x0_get (const ::PangoMatrix* obj) { return (gdouble) obj->x0; }
// gdouble Matrix::x0 (const ::PangoMatrix* obj /*none*/);
// gdouble Matrix::x0 (const ::PangoMatrix* obj /*none*/);
gdouble base::MatrixBase::x0_ () const noexcept
{
  typedef gdouble (*call_wrap_t) (const ::PangoMatrix* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_x0_get;
  auto _temp_ret = call_wrap_v ((const ::PangoMatrix*) (gobj_()));
  return _temp_ret;
}

static void _field_x0_set (::PangoMatrix* obj, gdouble _value) { obj->x0 = (decltype(obj->x0)) _value; }
//  Matrix::x0 (::PangoMatrix* obj /*none*/, gdouble _value);
// void Matrix::x0 (::PangoMatrix* obj /*none*/, gdouble _value);
void base::MatrixBase::x0_ (gdouble _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoMatrix* obj, gdouble _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_x0_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoMatrix*) (gobj_()), (gdouble) (_value_to_c));
}

static gdouble _field_y0_get (const ::PangoMatrix* obj) { return (gdouble) obj->y0; }
// gdouble Matrix::y0 (const ::PangoMatrix* obj /*none*/);
// gdouble Matrix::y0 (const ::PangoMatrix* obj /*none*/);
gdouble base::MatrixBase::y0_ () const noexcept
{
  typedef gdouble (*call_wrap_t) (const ::PangoMatrix* obj);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_y0_get;
  auto _temp_ret = call_wrap_v ((const ::PangoMatrix*) (gobj_()));
  return _temp_ret;
}

static void _field_y0_set (::PangoMatrix* obj, gdouble _value) { obj->y0 = (decltype(obj->y0)) _value; }
//  Matrix::y0 (::PangoMatrix* obj /*none*/, gdouble _value);
// void Matrix::y0 (::PangoMatrix* obj /*none*/, gdouble _value);
void base::MatrixBase::y0_ (gdouble _value) noexcept
{
  typedef void (*call_wrap_t) (::PangoMatrix* obj, gdouble _value);
  call_wrap_t call_wrap_v = (call_wrap_t) _field_y0_set;
  auto _value_to_c = _value;
  call_wrap_v ((::PangoMatrix*) (gobj_()), (gdouble) (_value_to_c));
}

// void pango_matrix_concat (PangoMatrix* matrix /*none*/, const PangoMatrix* new_matrix /*none*/);
// void pango_matrix_concat (::PangoMatrix* matrix /*none*/, const ::PangoMatrix* new_matrix /*none*/);
void base::MatrixBase::concat (const Pango::Matrix_Ref new_matrix) noexcept
{
  typedef void (*call_wrap_t) (::PangoMatrix* matrix, const ::PangoMatrix* new_matrix);
  call_wrap_t call_wrap_v = (call_wrap_t) ::pango_matrix_concat;
  auto new_matrix_to_c = gi::unwrap (new_matrix, gi::transfer_none);
  call_wrap_v ((::PangoMatrix*) (gobj_()), (const ::PangoMatrix*) (new_matrix_to_c));
}

// PangoMatrix* /*full,nullable*/ pango_matrix_copy (const PangoMatrix* matrix /*none,nullable*/);
// ::PangoMatrix* /*full,nullable*/ pango_matrix_copy (const ::PangoMatrix* matrix /*none,nullable*/);
Pango::Matrix base::MatrixBase::copy () const noexcept
{
  typedef ::PangoMatrix* (*call_wrap_t) (const ::PangoMatrix* matrix);
  call_wrap_t call_wrap_v = (call_wrap_t) ::pango_matrix_copy;
  auto _temp_ret = call_wrap_v ((const ::PangoMatrix*) (gobj_()));
  return gi::wrap (_temp_ret, gi::transfer_full);
}

// void pango_matrix_free (PangoMatrix* matrix /*none,nullable*/);
// void pango_matrix_free (::PangoMatrix* matrix /*none,nullable*/);
// IGNORE; marked ignore

// double pango_matrix_get_font_scale_factor (const PangoMatrix* matrix /*none,nullable*/);
// gdouble pango_matrix_get_font_scale_factor (const ::PangoMatrix* matrix /*none,nullable*/);
gdouble base::MatrixBase::get_font_scale_factor () const noexcept
{
  typedef gdouble (*call_wrap_t) (const ::PangoMatrix* matrix);
  call_wrap_t call_wrap_v = (call_wrap_t) ::pango_matrix_get_font_scale_factor;
  auto _temp_ret = call_wrap_v ((const ::PangoMatrix*) (gobj_()));
  return _temp_ret;
}

// void pango_matrix_get_font_scale_factors (const PangoMatrix* matrix /*none,nullable*/, double* xscale, double* yscale);
// void pango_matrix_get_font_scale_factors (const ::PangoMatrix* matrix /*none,nullable*/, gdouble* xscale, gdouble* yscale);
void base::MatrixBase::get_font_scale_factors (gdouble * xscale, gdouble * yscale) const noexcept
{
  typedef void (*call_wrap_t) (const ::PangoMatrix* matrix, gdouble* xscale, gdouble* yscale);
  call_wrap_t call_wrap_v = (call_wrap_t) ::pango_matrix_get_font_scale_factors;
  gdouble yscale_o {};
  gdouble xscale_o {};
  call_wrap_v ((const ::PangoMatrix*) (gobj_()), (gdouble*) (xscale ? &xscale_o : nullptr), (gdouble*) (yscale ? &yscale_o : nullptr));
  if (yscale) *yscale = yscale_o;
  if (xscale) *xscale = xscale_o;
}
std::tuple<gdouble, gdouble> base::MatrixBase::get_font_scale_factors () const noexcept
{
  typedef void (*call_wrap_t) (const ::PangoMatrix* matrix, gdouble* xscale, gdouble* yscale);
  call_wrap_t call_wrap_v = (call_wrap_t) ::pango_matrix_get_font_scale_factors;
  gdouble yscale_o {};
  gdouble xscale_o {};
  call_wrap_v ((const ::PangoMatrix*) (gobj_()), (gdouble*) (&xscale_o), (gdouble*) (&yscale_o));
  auto &&tmp_return_1 = xscale_o;
  auto &&tmp_return_2 = yscale_o;
  return std::make_tuple (std::move(tmp_return_1),std::move(tmp_return_2));
}

// double pango_matrix_get_slant_ratio (const PangoMatrix* matrix /*none*/);
// gdouble pango_matrix_get_slant_ratio (const ::PangoMatrix* matrix /*none*/);
gdouble base::MatrixBase::get_slant_ratio () const noexcept
{
  typedef gdouble (*call_wrap_t) (const ::PangoMatrix* matrix);
  call_wrap_t call_wrap_v = (call_wrap_t) ::pango_matrix_get_slant_ratio;
  auto _temp_ret = call_wrap_v ((const ::PangoMatrix*) (gobj_()));
  return _temp_ret;
}

// void pango_matrix_rotate (PangoMatrix* matrix /*none*/, double degrees);
// void pango_matrix_rotate (::PangoMatrix* matrix /*none*/, gdouble degrees);
void base::MatrixBase::rotate (gdouble degrees) noexcept
{
  typedef void (*call_wrap_t) (::PangoMatrix* matrix, gdouble degrees);
  call_wrap_t call_wrap_v = (call_wrap_t) ::pango_matrix_rotate;
  auto degrees_to_c = degrees;
  call_wrap_v ((::PangoMatrix*) (gobj_()), (gdouble) (degrees_to_c));
}

// void pango_matrix_scale (PangoMatrix* matrix /*none*/, double scale_x, double scale_y);
// void pango_matrix_scale (::PangoMatrix* matrix /*none*/, gdouble scale_x, gdouble scale_y);
void base::MatrixBase::scale (gdouble scale_x, gdouble scale_y) noexcept
{
  typedef void (*call_wrap_t) (::PangoMatrix* matrix, gdouble scale_x, gdouble scale_y);
  call_wrap_t call_wrap_v = (call_wrap_t) ::pango_matrix_scale;
  auto scale_y_to_c = scale_y;
  auto scale_x_to_c = scale_x;
  call_wrap_v ((::PangoMatrix*) (gobj_()), (gdouble) (scale_x_to_c), (gdouble) (scale_y_to_c));
}

// void pango_matrix_transform_distance (const PangoMatrix* matrix /*none,nullable*/, double* dx, double* dy);
// void pango_matrix_transform_distance (const ::PangoMatrix* matrix /*none,nullable*/, gdouble* dx, gdouble* dy);
void base::MatrixBase::transform_distance (gdouble & dx, gdouble & dy) const noexcept
{
  typedef void (*call_wrap_t) (const ::PangoMatrix* matrix, gdouble* dx, gdouble* dy);
  call_wrap_t call_wrap_v = (call_wrap_t) ::pango_matrix_transform_distance;
  auto dy_to_c = dy;
  gdouble dy_o = dy_to_c;
  auto dx_to_c = dx;
  gdouble dx_o = dx_to_c;
  call_wrap_v ((const ::PangoMatrix*) (gobj_()), (gdouble*) (&dx_o), (gdouble*) (&dy_o));
  dy = dy_o;
  dx = dx_o;
}

// void pango_matrix_transform_pixel_rectangle (const PangoMatrix* matrix /*none,nullable*/, PangoRectangle* rect /*full,inout,opt*/);
// void pango_matrix_transform_pixel_rectangle (const ::PangoMatrix* matrix /*none,nullable*/, ::PangoRectangle** rect /*full,inout,opt*/);
// SKIP; inconsistent rect inout pointer depth (1 vs 2)

// void pango_matrix_transform_point (const PangoMatrix* matrix /*none,nullable*/, double* x, double* y);
// void pango_matrix_transform_point (const ::PangoMatrix* matrix /*none,nullable*/, gdouble* x, gdouble* y);
void base::MatrixBase::transform_point (gdouble & x, gdouble & y) const noexcept
{
  typedef void (*call_wrap_t) (const ::PangoMatrix* matrix, gdouble* x, gdouble* y);
  call_wrap_t call_wrap_v = (call_wrap_t) ::pango_matrix_transform_point;
  auto y_to_c = y;
  gdouble y_o = y_to_c;
  auto x_to_c = x;
  gdouble x_o = x_to_c;
  call_wrap_v ((const ::PangoMatrix*) (gobj_()), (gdouble*) (&x_o), (gdouble*) (&y_o));
  y = y_o;
  x = x_o;
}

// void pango_matrix_transform_rectangle (const PangoMatrix* matrix /*none,nullable*/, PangoRectangle* rect /*full,inout,opt*/);
// void pango_matrix_transform_rectangle (const ::PangoMatrix* matrix /*none,nullable*/, ::PangoRectangle** rect /*full,inout,opt*/);
// SKIP; inconsistent rect inout pointer depth (1 vs 2)

// void pango_matrix_translate (PangoMatrix* matrix /*none*/, double tx, double ty);
// void pango_matrix_translate (::PangoMatrix* matrix /*none*/, gdouble tx, gdouble ty);
void base::MatrixBase::translate (gdouble tx, gdouble ty) noexcept
{
  typedef void (*call_wrap_t) (::PangoMatrix* matrix, gdouble tx, gdouble ty);
  call_wrap_t call_wrap_v = (call_wrap_t) ::pango_matrix_translate;
  auto ty_to_c = ty;
  auto tx_to_c = tx;
  call_wrap_v ((::PangoMatrix*) (gobj_()), (gdouble) (tx_to_c), (gdouble) (ty_to_c));
}


} // namespace base

} // namespace Pango

} // namespace repository

} // namespace gi


#if defined(__has_include)
#if __has_include(<pango/matrix_extra_def_impl.hpp>)
#include <pango/matrix_extra_def_impl.hpp>
#endif
#endif


#if defined(__has_include)
#if __has_include(<pango/matrix_extra_impl.hpp>)
#include <pango/matrix_extra_impl.hpp>
#endif
#endif

#endif
